Rules for AI-Assisted Web Projects

1. Core Philosophy & Environment

The Golden Rule: The project must be fully functional when index.html is opened directly in a browser from the local file system (using the file:/// protocol). Advanced, server-dependent features (like Service Workers for offline caching) should be implemented to degrade gracefully (i.e., not run and not cause errors) in this environment.
No Servers or Build Tools: The solution must not require a local web server (like "Live Server") or any command-line tools for building, compiling, or package management (npm, Vite, etc.).
Client-Side Only: All code must run entirely in the browser. There is no backend.
Robustness First: The application must be resilient. This includes providing fallbacks for potentially failing external resources (like CDNs) and handling potential runtime errors gracefully.

2. Project Structure & Modularity

A highly modular, multi-file structure is mandatory for organization and scalability.
JavaScript Modularity: The application logic must be split into multiple, single-responsibility files. The established pattern is:
Data Files: billers.js, locations.js, kb-articles.js, etc.
Data-Specific Notes: A src/live/ directory for large, biller-specific data files (e.g., BGE.js).
Core Logic: app-core.js (global state, DOM cache), app-features.js (settings, analytics), and feature-specific logic files (location-feature.js, notes-feature.js).
UI Rendering: ui-components.js (UI object definition), ui-notes.js (notes-specific rendering).
Initialization: app-main.js (the final script that starts the app).
CSS Architecture: Stylesheets must be split for maintainability:
theme.css: Contains only CSS custom properties (variables) for colors, fonts, and spacing for both light and dark themes. This file controls the "look and feel."
styles.css: Contains all structural and layout rules for components, animations, and responsive design. This file controls the "shape and behavior."
Feature-Specific CSS: Additional, self-contained stylesheets for complex components (e.g., notes.css) are encouraged.

3. Code & Functionality

Core Technologies: The project must only use HTML, CSS, and vanilla JavaScript (ES6+). No frameworks (React, Vue) or external component libraries (Material UI, Bootstrap) are permitted.
JavaScript Communication & Loading Order:
No ES Modules: The keywords import/export and <script type="module"> are strictly forbidden to ensure file:/// compatibility.
Global Scope: Communication between .js files must be achieved by declaring global constants and objects (e.g., const BILLERS = [...], const UI = {}).
Critical Script Order: The <script> tags in index.html must be ordered meticulously to ensure that data and objects are defined before any script that attempts to use them. The initialization script (app-main.js) must always be last.
Defensive Programming & Error Handling:
Null Checks: Always check if a DOM element exists (is not null) before attempting to access its properties or methods.
Error Boundaries: Wrap critical initialization blocks (like the main init() function) in a try...catch block to prevent a single failure from crashing the entire application and to provide clear error feedback.
UI/UX & Accessibility:
User Feedback: All interactive elements must provide clear visual feedback, such as hover effects, active states, and focus indicators (:focus-visible).
Informative UI: Use tooltips to explain the function of controls and display keyboard shortcuts where applicable.
Accessibility: Use semantic HTML and ARIA attributes where necessary to ensure the application is accessible.

4. AI Collaboration & Workflow

The Planning Rule: For any request involving multiple files or significant feature changes, the AI must first devise a detailed plan.
Plan Requirements: The plan must include:
A clear diagnosis of the problem or an outline of the new feature.
A proposed solution, detailing the implementation strategy.
A complete list of all new and modified files.
Approval is Mandatory: The AI must not generate any code until the user has explicitly reviewed and approved the plan.



//////////////////////////////////////////////







Definitive Rules List for the Biller Hub Project

1. Core Philosophy & Environment
The Golden Rule: The project's primary version must be fully functional when index.html is opened directly in a browser from the local file system (using the file:/// protocol).
No Server Dependencies: All features that require a web server must be disabled by design in the code. This includes:
Service Workers: The code to register a service worker must not be present.
Web Workers: The code to initialize a web worker must be removed in favor of a main-thread fallback.
Advanced Caching: The application must not use IndexedDB or any other complex caching mechanism that is unreliable on the file:// protocol. Data should be loaded from source files on every visit.
No Build Tools: The solution must not require a local web server (like "Live Server") or any command-line tools for building, compiling, or package management (npm, Vite, etc.).
Client-Side Only: All code must run entirely in the browser. There is no backend.

2. Project Structure & Modularity
Mandatory Modularity: A highly modular, multi-file structure is mandatory for organization and scalability.
JavaScript Architecture: The application logic must be split into the following single-responsibility files:
Data Files:
biller-data-all.js: A single, consolidated file for the main BILLERS array.
/data/: Folder for other static data like locations.js, kb-articles.js.
/live/: A directory for large, biller-specific note files (e.g., DNE.js, CEB.js).

Core & Feature Logic:
app-core.js: Contains the global state object and dom element cache.
app-features.js: Contains the non-UI logic for features like Settings and Analytics.
/features/: Folder for self-contained feature logic (e.g., location-feature.js, notes-feature.js).
UI Rendering (Three-Part Structure):
ui-core.js: Defines the global const UI = { ... }; object and contains the most critical rendering functions (displayBiller, renderSuggestions, etc.).
ui-components.js: Contains logic for generic, reusable widgets (Modal, Drawer, Popover) and appends them to the UI object.
ui-features.js: Contains logic for specific feature panels (Favorites, Settings, etc.) and appends them to the UI object.

Initialization:
app-main.js: The final script that orchestrates the application startup.
CSS Architecture: Stylesheets must be split for maintainability:
theme.css: Contains only CSS custom properties (variables) for all themes.
styles.css: Contains structural and layout rules for core components.
components.css, search.css, notes.css: Self-contained stylesheets for complex components.

3. Code & Functionality
Core Technologies: The project must only use HTML, CSS, and vanilla JavaScript (ES6+). No frameworks (React, Vue) or external component libraries are permitted.
JavaScript Loading & Communication:
No ES Modules: The keywords import/export and <script type="module"> are strictly forbidden to ensure file:/// compatibility.
Global Scope: Communication between .js files is achieved via global constants and objects.
The const UI = { ... }; declaration must only exist in ui-core.js. All other UI files must append to it (e.g., UI.Modal = { ... };).
Critical Script Order: The <script> tags in index.html must be ordered meticulously in the following sequence:
Libraries (fuse.min.js)
All Data (biller-data-all.js, all /live/ note files, etc.)
Core Logic (app-core.js, utils.js, etc.)
UI Logic (in order: ui-core.js, ui-components.js, ui-features.js, ui-notes.js)
Feature Logic (app-features.js, etc.)
Main Initializer (app-main.js must be last).

Defensive Programming:
Wrap the main init() function in a try...catch block to prevent a single failure from crashing the entire application.
At startup, verify that the global BILLERS array has been loaded correctly before proceeding.
4. Data Structure & Flexibility
Flexible Contact Information: All biller phone numbers and contacts must be stored in a contacts array within the biller's object in biller-data-all.js. Each object in the array must have type, label, value, and an optional note.
Unique Biller Data: For unique, non-standard information, use an optional customFields array of { label, value } objects. The UI must be able to render these fields automatically.
Complex Biller Notes: For billers with multiple divisions or complex rules (like DNE, CEB), the corresponding note file (e.g., DNE.js) must use the "Composite" data structure, containing alerts, generalInfo, and services properties.

5. AI Collaboration & Workflow
The Planning Rule: For any request involving multiple files or significant feature changes, the AI must first devise a detailed plan.
Plan Requirements: The plan must include:
A clear diagnosis of the problem or an outline of the new feature.
A proposed solution, detailing the implementation strategy.
A complete list of all new and modified files.
Approval is Mandatory: The AI must not generate any code until the user has explicitly reviewed and approved the plan.

