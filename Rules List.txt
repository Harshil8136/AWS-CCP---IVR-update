Rules for AI-Assisted Web Projects

1. Core Philosophy & Environment

The Golden Rule: The project must be fully functional when index.html is opened directly in a browser from the local file system (using the file:/// protocol). Advanced, server-dependent features (like Service Workers for offline caching) should be implemented to degrade gracefully (i.e., not run and not cause errors) in this environment.
No Servers or Build Tools: The solution must not require a local web server (like "Live Server") or any command-line tools for building, compiling, or package management (npm, Vite, etc.).
Client-Side Only: All code must run entirely in the browser. There is no backend.
Robustness First: The application must be resilient. This includes providing fallbacks for potentially failing external resources (like CDNs) and handling potential runtime errors gracefully.

2. Project Structure & Modularity

A highly modular, multi-file structure is mandatory for organization and scalability.
JavaScript Modularity: The application logic must be split into multiple, single-responsibility files. The established pattern is:
Data Files: billers.js, locations.js, kb-articles.js, etc.
Data-Specific Notes: A src/live/ directory for large, biller-specific data files (e.g., BGE.js).
Core Logic: app-core.js (global state, DOM cache), app-features.js (settings, analytics), and feature-specific logic files (location-feature.js, notes-feature.js).
UI Rendering: ui-components.js (UI object definition), ui-notes.js (notes-specific rendering).
Initialization: app-main.js (the final script that starts the app).
CSS Architecture: Stylesheets must be split for maintainability:
theme.css: Contains only CSS custom properties (variables) for colors, fonts, and spacing for both light and dark themes. This file controls the "look and feel."
styles.css: Contains all structural and layout rules for components, animations, and responsive design. This file controls the "shape and behavior."
Feature-Specific CSS: Additional, self-contained stylesheets for complex components (e.g., notes.css) are encouraged.

3. Code & Functionality

Core Technologies: The project must only use HTML, CSS, and vanilla JavaScript (ES6+). No frameworks (React, Vue) or external component libraries (Material UI, Bootstrap) are permitted.
JavaScript Communication & Loading Order:
No ES Modules: The keywords import/export and <script type="module"> are strictly forbidden to ensure file:/// compatibility.
Global Scope: Communication between .js files must be achieved by declaring global constants and objects (e.g., const BILLERS = [...], const UI = {}).
Critical Script Order: The <script> tags in index.html must be ordered meticulously to ensure that data and objects are defined before any script that attempts to use them. The initialization script (app-main.js) must always be last.
Defensive Programming & Error Handling:
Null Checks: Always check if a DOM element exists (is not null) before attempting to access its properties or methods.
Error Boundaries: Wrap critical initialization blocks (like the main init() function) in a try...catch block to prevent a single failure from crashing the entire application and to provide clear error feedback.
UI/UX & Accessibility:
User Feedback: All interactive elements must provide clear visual feedback, such as hover effects, active states, and focus indicators (:focus-visible).
Informative UI: Use tooltips to explain the function of controls and display keyboard shortcuts where applicable.
Accessibility: Use semantic HTML and ARIA attributes where necessary to ensure the application is accessible.

4. AI Collaboration & Workflow

The Planning Rule: For any request involving multiple files or significant feature changes, the AI must first devise a detailed plan.
Plan Requirements: The plan must include:
A clear diagnosis of the problem or an outline of the new feature.
A proposed solution, detailing the implementation strategy.
A complete list of all new and modified files.
Approval is Mandatory: The AI must not generate any code until the user has explicitly reviewed and approved the plan.


5. UI & Data Consistency:
UI & Data Consistency:
All biller-specific notes (e.g., BGE.js, PAC.js) must follow a standardized structure to ensure a consistent user experience.
Common information must be organized into a set of standard, short-named tabs. The standard tabs are: Alerts, Fees, Contact, Channels, and System.
The standard tabs must be defined in the following order within the notes object to ensure a consistent on-page sequence:
alerts (danger color)
fees (primary color)
contact (info color)
channels (info color)
system (secondary color)
Information unique to a biller that does not fit into a standard category should be placed in a new, custom-named tab after the standard tabs.

//////////////////////////////////////////////



Project Rules
1. Core Philosophy & Environment
The project must be fully functional when index.html is opened directly from the local file system (file:/// protocol). Server-dependent features must degrade gracefully.
No local web server or command-line build tools (npm, Vite, etc.) are required.
All code must be client-side only.
The application must be robust, with fallbacks for failing external resources and graceful error handling.

2. Project Structure & Modularity
A highly modular, multi-file structure is mandatory.
JavaScript: Logic must be split into single-responsibility files (Data, Core Logic, UI Rendering, Features, Initialization).
CSS: Stylesheets must be split (theme.css for variables, and separate files like base.css, header.css, biller-card.css for structure and layout).

3. Code & Functionality
Core Technologies: HTML, CSS, and vanilla JavaScript (ES6+) only. No frameworks or external component libraries.
JavaScript Communication: No import/export. Communication is achieved via the global scope and a meticulous script loading order in index.html.
Defensive Programming: Always check for null DOM elements before use and wrap critical initialization blocks in try...catch.

4. AI Collaboration & Workflow
For any significant feature change, the AI must first devise a detailed plan listing all new and modified files.
The AI must not generate any code until the user has explicitly reviewed and approved the plan.

5. UI & Data Consistency
All biller-specific notes (e.g., BGE.js, PAC.js) must follow a standardized structure to ensure a consistent user experience.
The standard tabs must be defined in this exact order: alerts (danger), fees (primary), contact (info), channels (info), system (secondary).

6. Refactoring Integrity (New)
When a function or object is moved from a source file to a new destination file as part of refactoring, all other files that call or reference that code must be updated to use its new location.

7. DOM Caching and Injection Order (New)
Scripts must not attempt to cache DOM elements that are injected at runtime before the injection occurs. The correct operational sequence is: (1) Inject HTML templates into the DOM, (2) then cache the newly-added elements by ID, and (3) then attach event listeners to them.

8. Data Contract Consistency (New)
Any function that consumes data from another file (e.g., a feature module consuming a data module) must be written to match the exact data structure of the source file. If a data source's structure is changed, the consuming function must be updated in the same step.

9. Asset Loading (New)
Whenever a new .js or .css file is created, a corresponding <script> or <link> tag must be added to index.html in the correct, dependency-aware order to ensure it is loaded by the browser.

10. AI Output Formatting (New)
The AI must never include citation markers (e.g., ``) in any generated file or code block. All generated content must be clean of these markers.
